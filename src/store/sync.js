import { nanoid } from 'nanoid';
import * as Vue from 'vue';
import { reactive } from 'vue';
// import { Doc } from "yjs"
import { enableVueBindings, syncedStore, getYjsValue } from '@syncedstore/core';

import { WebrtcProvider } from 'y-webrtc';
import { IndexeddbPersistence } from 'y-indexeddb';

import EventEmitter from '@/utils/event';
// import * as T from "./types"
// import { DocTypeDescription } from '@syncedstore/core/types/doc';

enableVueBindings(Vue);

export default class SyncedDocument extends EventEmitter {
    constructor(storeStructure, documentId) {
        super();

        this.users = reactive({});

        this.id = documentId || nanoid();
        this.store = syncedStore(storeStructure);

        const doc = getYjsValue(this.store);

        this.syncProvider = new WebrtcProvider(this.id, doc);
        this.saveProvider = new IndexeddbPersistence(this.id, doc);

        this.syncProvider.awareness.on('change', this.handleChanges.bind(this));

        this.saveProvider.on('synced', () => {
            console.log('Save provider synced.', this.store.metadata.name);
            // Generate a random user id, then update the awareness.
            this.userId = nanoid();
            this.syncProvider.awareness.setLocalStateField('id', this.userId);

            if (!this.store.metadata.id) this.store.metadata.id = this.id;
            if (!this.store.metadata.name) this.store.metadata.name = 'Untitled';

            this.localUser = reactive(this.users[this.userId]);

            this.emit('synced');
        });

        console.warn = () => null; // Supress the numerous warnings generated by SyncedStore.
    }

    close() {
        this.syncProvider.destroy();
    }

    // eslint-disable-next-line
    updateAwareness(key, value) {
        this.syncProvider.awareness.setLocalStateField(key, value);
    }

    registerAwarenessCallback(key, callback) {
        this.syncProvider.awareness.on(key, callback);
    }

    handleChanges() {
        const awarenessInfo = [...this.syncProvider.awareness.getStates().values()];
        const onlineUsers = new Set();
        const offlineUsers = new Set(Object.keys(this.users));

        awarenessInfo.forEach((user) => {
            onlineUsers.add(user.id);
            offlineUsers.delete(user.id);

            if (!this.users[user.id]) this.users[user.id] = {};
            Object.entries(user).forEach(([key, value]) => {
                this.users[user.id][key] = value;
            });
        });

        offlineUsers.forEach((userId) => delete this.users[userId]);
    }
}
