import { nanoid } from 'nanoid';
import * as Vue from 'vue';
import { reactive } from 'vue';
import isElectron from 'is-electron';
import { enableVueBindings, syncedStore, getYjsValue } from '@syncedstore/core';

import { WebrtcProvider } from 'y-webrtc';
import { IndexeddbPersistence } from 'y-indexeddb';
import EventEmitter from '@/utils/event';
import LocalFilePersistence from './persist';

// import * as T from "./types"
// import { DocTypeDescription } from '@syncedstore/core/types/doc';

enableVueBindings(Vue);

export default class SyncedDocument extends EventEmitter {
    constructor(storeStructure) {
        super();
        this.syncInitialized = false;
        this.store = syncedStore(storeStructure);
        console.warn = () => null; // Supress the numerous warnings generated by SyncedStore.
    }

    initSync(documentId) {
        this.users = reactive({});
        this.store.metadata.id = documentId || nanoid();

        const doc = getYjsValue(this.store);
        this.syncProvider = new WebrtcProvider(this.store.metadata.id, doc);
        this.syncProvider.awareness.on('change', this.handleChanges.bind(this));

        // Generate a random user id, then update the awareness.
        this.userId = nanoid();
        this.syncProvider.awareness.setLocalStateField('id', this.userId);
        // if (!this.store.metadata.name) this.store.metadata.name = 'Untitled';

        this.localUser = reactive(this.users[this.userId]);

        this.syncInitialized = true;
    }

    initPersistence(filePath) {
        const doc = getYjsValue(this.store);
        this.saveProvider = isElectron()
            ? new LocalFilePersistence(filePath, doc)
            : new IndexeddbPersistence(filePath, doc);

        this.saveProvider.on('synced', () => {
            console.log('[Sync][saveProvider@synced] Save provider synced.', this.store.metadata.id);
            if (!this.syncInitialized) this.initSync(this.store.metadata.id);
            this.emit('synced');
        });

        this.saveProvider.on('saved', () => {
            console.log('[Sync][saveProvider@synced] Save provider saved.');
            this.emit('saved');
        });
    }

    close() {
        this.syncProvider.destroy();
    }

    // eslint-disable-next-line
    updateAwareness(key, value) {
        if (!this.syncInitialized) return;
        this.syncProvider.awareness.setLocalStateField(key, value);
    }

    registerAwarenessCallback(key, callback) {
        this.syncProvider.awareness.on(key, callback);
    }

    handleChanges() {
        const awarenessInfo = [...this.syncProvider.awareness.getStates().values()];
        const onlineUsers = new Set();
        const offlineUsers = new Set(Object.keys(this.users));

        awarenessInfo.forEach((user) => {
            onlineUsers.add(user.id);
            offlineUsers.delete(user.id);

            if (!this.users[user.id]) this.users[user.id] = {};
            Object.entries(user).forEach(([key, value]) => {
                this.users[user.id][key] = value;
            });
        });

        offlineUsers.forEach((userId) => delete this.users[userId]);
    }

    stringify() {
        return JSON.stringify(this.store);
    }
}
