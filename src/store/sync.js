import { nanoid } from 'nanoid';
import * as Vue from 'vue';
import { reactive } from 'vue';
import isElectron from 'is-electron';
import { enableVueBindings, syncedStore, getYjsValue } from '@syncedstore/core';
import jiff from 'jiff';

import { WebrtcProvider } from 'y-webrtc';
import { IndexeddbPersistence } from 'y-indexeddb';
import EventEmitter from '@/utils/event';
import LocalFilePersistence from './persist';

// import * as T from "./types"
// import { DocTypeDescription } from '@syncedstore/core/types/doc';

enableVueBindings(Vue);

export default class SyncedDocument extends EventEmitter {
    constructor(storeStructure) {
        super();
        this.syncInitialized = false;
        this.storeStructure = storeStructure;
        this.store = reactive({ ...storeStructure });
        this.syncedData = syncedStore(storeStructure);
        this.remoteUpdated = false;
        console.warn = () => null; // Supress the numerous warnings generated by SyncedStore.
    }

    initSync(documentId) {
        console.log(`[Sync][initSync] Initializing sync with docID ${documentId}.`);
        this.users = reactive({});
        this.store.metadata.id = documentId || nanoid();
        // this.syncedData.metadata.id = this.store.metadata.id;
        this.updateSyncedData();

        const doc = getYjsValue(this.syncedData);
        this.syncProvider = new WebrtcProvider(this.store.metadata.id, doc);
        this.syncProvider.awareness.on('change', this.handleChanges.bind(this));
        doc.on('update', (_, origin) => {
            if (origin) this.remoteUpdated = true;
        });

        doc.on('afterTransaction', () => {
            if (this.remoteUpdated) this.emit('sync');
            this.remoteUpdated = false;
        });

        // Generate a random user id, then update the awareness.
        this.userId = nanoid();
        this.syncProvider.awareness.setLocalStateField('id', this.userId);
        // if (!this.store.metadata.name) this.store.metadata.name = 'Untitled';

        this.localUser = reactive(this.users[this.userId]);

        this.syncInitialized = true;
    }

    initPersistence(filePath) {
        console.log(filePath);
        const doc = getYjsValue(this.syncedData);
        this.saveProvider = isElectron()
            ? new LocalFilePersistence(filePath, doc)
            : new IndexeddbPersistence(filePath || this.store.metadata.id, doc);

        this.saveProvider.on('synced', () => {
            console.log('[Sync][saveProvider@synced] Save provider synced.', this.syncedData.metadata.id);
            this.store = JSON.parse(JSON.stringify(this.syncedData));
            if (!this.syncInitialized) this.initSync(this.syncedData.metadata.id);
            this.emit('synced');
        });

        this.saveProvider.on('save', () => {
            console.log('[Sync][saveProvider@synced] Saving to disk...');
            this.emit('save');
        });

        this.saveProvider.on('saved', () => {
            console.log('[Sync][saveProvider@synced] Save provider saved.');
            this.emit('saved');
        });
    }

    updateSyncedData() {
        console.log('[Sync][updateSyncedData] Updating synced data from store after commit.');
        const changes = jiff.diff(this.syncedData, this.store).filter(
            (change) => change.path !== '/fragment',
        );
        jiff.patchInPlace(changes, this.syncedData);
    }

    updateStoreData() {
        console.log('[Sync][updateStoreData] Updating store data from upon sync update.');
        const changes = jiff.diff(this.store, this.syncedData).filter(
            (change) => change.path !== '/fragment',
        );
        jiff.patchInPlace(changes, this.store);
    }

    close() {
        this.syncProvider.destroy();
    }

    // eslint-disable-next-line
    updateAwareness(key, value) {
        if (!this.syncInitialized) return;
        this.syncProvider.awareness.setLocalStateField(key, value);
    }

    registerAwarenessCallback(key, callback) {
        this.syncProvider.awareness.on(key, callback);
    }

    handleChanges() {
        const awarenessInfo = [...this.syncProvider.awareness.getStates().values()];
        const onlineUsers = new Set();
        const offlineUsers = new Set(Object.keys(this.users));

        awarenessInfo.forEach((user) => {
            onlineUsers.add(user.id);
            offlineUsers.delete(user.id);

            if (!this.users[user.id]) this.users[user.id] = {};
            Object.entries(user).forEach(([key, value]) => {
                this.users[user.id][key] = value;
            });
        });

        offlineUsers.forEach((userId) => delete this.users[userId]);
    }

    stringify() {
        return JSON.stringify(this.store);
    }
}
